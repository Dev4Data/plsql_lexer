`STATEMENT_CLASSIFIER`
============

Statement classifier is a PL/SQL package to determine the category, statement
type, command name, and command type (id) for a single SQL or PL/SQL statement.

This information can help programs decide how to handle different statements.
For example, a program may need to decide to:

- Inspect the results if it is a SELECT statement.
- Look at SQL%ROWCOUNT and COMMIT the transaction if it is a DML statement.
- Prevent the code from running if it is a PL/SQL statement.


## Example

    declare
        v_category       varchar2(100);
        v_statement_type varchar2(100);
        v_command_name   varchar2(64);
        v_command_type   number;
        v_lex_sqlcode    number;
        v_lex_sqlerrm    varchar2(4000);
    begin
        statement_classifier.classify(
            '(with test as (select * from dual) select * from test)',
            v_category,v_statement_type,v_command_name,v_command_type,v_lex_sqlcode,v_lex_sqlerrm
        );

        if v_category is null then
            dbms_output.put_line('Cannot classify the statement.');
        else
            dbms_output.put_line('Category      : '||v_category);
            dbms_output.put_line('Statement Type: '||v_statement_type);
            dbms_output.put_line('Command Name  : '||v_command_name);
            dbms_output.put_line('Command Type  : '||v_command_type);
            dbms_output.put_line('Lex SQLCODE   : '||v_lex_sqlcode);
            dbms_output.put_line('Lex SQLERRM   : '||v_lex_sqlerrm);
        end if;
    end;
    /

Results:

    Category      : DML
    Statement Type: SELECT
    Command Name  : SELECT
    Command Type  : 3
    Lex SQLCODE   : 
    Lex SQLERRM   : 


## Parameters

- `p_statement` (IN):  The input code.
- `p_category` (OUT):  One of DDL, DML, Transaction Control, Session Control,
    System Control, or PL/SQL.
- `p_statement_type` (OUT):  More descriptive than category.  For example, INSERT,
    SELECT, or CREATE.

    Here are the possible combinations of `P_CATEGORY` and `P_STATEMENT_TYPE`, as
    defined by the manual (except for PL/SQL, which I added)

        DDL
          ADMINISTER KEY MANAGEMENT, ALTER (except ALTER SESSION and ALTER SYSTEM),
          ANALYZE,ASSOCIATE STATISTICS,AUDIT,COMMENT,CREATE,DISASSOCIATE STATISTICS,
          DROP,FLASHBACK,GRANT,NOAUDIT,PURGE,RENAME,REVOKE,TRUNCATE
        DML
          CALL,DELETE,EXPLAIN PLAN,INSERT,LOCK TABLE,MERGE,SELECT,UPDATE
        Transaction Control
          COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION,SET CONSTRAINT
        Session Control
          ALTER SESSION,SET ROLE
        System Control
          ALTER SYSTEM
        PL/SQL
          BLOCK

- `p_command_name` (OUT):  This is usually more specific than the statement type
    and is based on `V$SQLCOMMAND`.  For example, `CREATE PLUGGABLE DATABASE`.
- `p_command_type` (OUT):  This is an ID number assigned to each command name,
    as defind by `V$SQLCOMMAND`.
- `p_lex_sqlcode` (OUT):  The first SQL error code generated by scanning the
    statement.  This package does *NOT* fully parse the statement.  An error
    code implies there is a serious syntax error, such as a non-terminated
    string or an identifer greater than 30 bytes long.  The statement is
    still classified but likely will not run.
- `p_lex_sqlerrm` (OUT):  The `SQLERRM` associated with the `SQLCODE` above.

All OUT parameters are null if the statement cannot be classified.  That will
only happen if the statement has major syntax problems.


## How to Install

1. Create objects on the desired schema:

        alter session set current_schema=&SCHEMA_NAME;
        
        create or replace type token is object
        (
            type     varchar2(4000),
            value    nclob,
            --Although called "SQL" code and errm, these may also apply to PL/SQL.
            --They would not match the real PL/SQL error messages, but the information
            --should still be helpful to parse broken code.
            sqlcode  number,
            sqlerrm  varchar2(4000)
        );
        
        --Use VARRAY because it is guaranteed to maintain order.
        create or replace type token_table is varray(2147483647) of token;

2. Install packages on the desired schema:

        alter session set current_schema=&SCHEMA_NAME;
        @tokenizer.pck
        @statement_classifier.pck

3. Install unit tests (optional):

        @/tests/tokenizer_test.pck
        @/tests/statement_classifier_test.pck

## License
`statement_classifier` is licensed under the LGPL.
