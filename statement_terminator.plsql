create or replace package statement_terminator is
--Copyright (C) 2015 Jon Heller.  This program is licensed under the LGPLv3.

function remove_semicolon(
	p_tokens in token_table
) return nclob;

function remove_sqlplus_delimiter(
	p_statement in nclob,
	p_sqlplus_delimiter in nvarchar2 default '/'
) return nclob;

function remove_semi_and_sqlplus_del(
	p_tokens in token_table,
	p_sqlplus_delimiter in nvarchar2 default '/'
) return nclob;

/*

== PURPOSE ==

Statement Terminator removes terminating semicolons and SQL*Plus delimiters from
the end of a statement. This is helpful when the statement will be executed as
dynamic SQL.

Dynamic SQL requires some commands must include a terminating semicolon and
other commands must not include a semicolon.  For example, "create table ..."
must not have a semicolon, but "create procedure ..." must end with a semicolon.

Only the last semicolon is removed.  Just like with SQL*Plus, statements
that end with two semicolons will not work correctly.

Semicolons may not be removed if the statement has a serious parsing error, like
an unclosed comment.


== EXAMPLE ==

select statement_semicolon_remover.remove(tokenizer.tokenize('select * from dual;'))
from dual;

Results:

select * from dual


== PARAMETERS ==

- p_tokens  (IN):           Tokens for a statement, probably generated by tokenizer.
- p_statement (IN):         A SQL statement.
- p_sqlplus_delimiter (IN): A SQL*Plus delimiter, usually "/".  Remember that
                            SQL*Plus delimiters must be on a line with only
                            whitespace.
*/

end;
/
create or replace package body statement_terminator is

--------------------------------------------------------------------------------
--Build the statement excluding the last semicolon, if any.
function build_statement_wo_semicolon(p_abstract_tokens token_table)
return nclob is
	v_statement nclob;
	v_semicolon_index number := -1;
begin
	--Find the index of the last semicolon token.
	--Only count it if it's the last concrete token.
	for i in reverse 1 .. p_abstract_tokens.count loop
		--Record index if it's a semicolon.
		if p_abstract_tokens(i).type = ';' then
			v_semicolon_index := i;
		--Quit the loop if another concrete token is found.
		elsif p_abstract_tokens(i).type not in ('comment', 'whitespace', 'EOF') then
			exit;
		end if;
	end loop;

	--Put together string, excluding the semicolon;
	for i in 1 .. p_abstract_tokens.count loop
		if i <> v_semicolon_index then
			v_statement := v_statement || p_abstract_tokens(i).value;
		end if;
	end loop;

	return v_statement;
end build_statement_wo_semicolon;


--------------------------------------------------------------------------------
--Return the statement without any modification.
function build_statement_as_is(p_abstract_tokens token_table)
return nclob is
	v_statement nclob;
begin
	for i in 1 .. p_abstract_tokens.count loop
		v_statement := v_statement || p_abstract_tokens(i).value;
	end loop;

	return v_statement;
end build_statement_as_is;


--------------------------------------------------------------------------------
--Remove extra semicolons, if any, to prepare for dynamic execution.
function remove_semicolon(p_tokens in token_table) return nclob is
	v_command_name varchar2(4000);
	v_lex_sqlcode  number;
	v_lex_sqlerrm  varchar2(4000);
	v_throwaway    varchar2(4000);
begin
	--Classify the tokens/statement.
	statement_classifier.classify(
		p_tokens => p_tokens,
		p_category => v_throwaway,
		p_statement_type => v_throwaway,
		p_command_name => v_command_name,
		p_command_type => v_throwaway,
		p_lex_sqlcode => v_lex_sqlcode,
		p_lex_sqlerrm => v_lex_sqlerrm
	);

	--Do nothing if there's a serious parsing error:
	if v_lex_sqlcode is not null or v_lex_sqlerrm is not null then
		return build_statement_as_is(p_tokens);
	--Remove semicolons from these:
	elsif v_command_name in (
		'ADMINISTER KEY MANAGEMENT','ALTER ASSEMBLY','ALTER AUDIT POLICY','ALTER CLUSTER','ALTER DATABASE',
		'ALTER DATABASE LINK','ALTER DIMENSION','ALTER DISK GROUP','ALTER EDITION','ALTER FLASHBACK ARCHIVE',
		'ALTER FUNCTION','ALTER INDEX','ALTER INDEXTYPE','ALTER JAVA','ALTER LIBRARY','ALTER MATERIALIZED VIEW ',
		'ALTER MATERIALIZED VIEW LOG','ALTER MATERIALIZED ZONEMAP','ALTER OPERATOR','ALTER OUTLINE',
		'ALTER PACKAGE','ALTER PACKAGE BODY','ALTER PLUGGABLE DATABASE','ALTER PROCEDURE','ALTER PROFILE',
		'ALTER RESOURCE COST',/*'ALTER REWRITE EQUIVALENCE',*/'ALTER ROLE','ALTER ROLLBACK SEGMENT',
		'ALTER SEQUENCE','ALTER SESSION',/*'ALTER SUMMARY',*/'ALTER SYNONYM','ALTER SYSTEM','ALTER TABLE',
		'ALTER TABLESPACE','ALTER TRACING','ALTER TRIGGER','ALTER TYPE','ALTER TYPE BODY','ALTER USER',
		'ALTER VIEW','ANALYZE CLUSTER','ANALYZE INDEX','ANALYZE TABLE','ASSOCIATE STATISTICS','AUDIT OBJECT',
		'CALL METHOD',/*'CHANGE PASSWORD',*/'COMMENT','COMMIT',/*'CREATE ASSEMBLY',*/'CREATE AUDIT POLICY',
		/*'CREATE BITMAPFILE',*/'CREATE CLUSTER','CREATE CONTEXT','CREATE CONTROL FILE','CREATE DATABASE',
		'CREATE DATABASE LINK','CREATE DIMENSION','CREATE DIRECTORY','CREATE DISK GROUP','CREATE EDITION',
		'CREATE FLASHBACK ARCHIVE',/*'CREATE FUNCTION',*/'CREATE INDEX','CREATE INDEXTYPE',/*'CREATE JAVA',*/
		/*'CREATE LIBRARY',*/'CREATE MATERIALIZED VIEW ','CREATE MATERIALIZED VIEW LOG','CREATE MATERIALIZED ZONEMAP',
		'CREATE OPERATOR','CREATE OUTLINE',/*'CREATE PACKAGE',*//*'CREATE PACKAGE BODY',*/'CREATE PFILE',
		'CREATE PLUGGABLE DATABASE',/*'CREATE PROCEDURE',*/'CREATE PROFILE','CREATE RESTORE POINT','CREATE ROLE',
		'CREATE ROLLBACK SEGMENT','CREATE SCHEMA','CREATE SCHEMA SYNONYM','CREATE SEQUENCE','CREATE SPFILE',
		/*'CREATE SUMMARY',*/'CREATE SYNONYM','CREATE TABLE','CREATE TABLESPACE',/*'CREATE TRIGGER',*//*'CREATE TYPE',*/
		/*'CREATE TYPE BODY',*/'CREATE USER','CREATE VIEW',/*'DECLARE REWRITE EQUIVALENCE',*/'DELETE',
		'DISASSOCIATE STATISTICS','DROP ASSEMBLY','DROP AUDIT POLICY',/*'DROP BITMAPFILE',*/'DROP CLUSTER',
		'DROP CONTEXT','DROP DATABASE','DROP DATABASE LINK','DROP DIMENSION','DROP DIRECTORY','DROP DISK GROUP',
		'DROP EDITION','DROP FLASHBACK ARCHIVE','DROP FUNCTION','DROP INDEX','DROP INDEXTYPE','DROP JAVA',
		'DROP LIBRARY','DROP MATERIALIZED VIEW ','DROP MATERIALIZED VIEW  LOG','DROP MATERIALIZED ZONEMAP',
		'DROP OPERATOR','DROP OUTLINE','DROP PACKAGE','DROP PACKAGE BODY','DROP PLUGGABLE DATABASE',
		'DROP PROCEDURE','DROP PROFILE','DROP RESTORE POINT',/*'DROP REWRITE EQUIVALENCE',*/'DROP ROLE',
		'DROP ROLLBACK SEGMENT','DROP SCHEMA SYNONYM','DROP SEQUENCE',/*'DROP SUMMARY',*/'DROP SYNONYM',
		'DROP TABLE','DROP TABLESPACE','DROP TRIGGER','DROP TYPE','DROP TYPE BODY','DROP USER','DROP VIEW',
		/*'Do not use 184',*//*'Do not use 185',*//*'Do not use 186',*/'EXPLAIN','FLASHBACK DATABASE',
		'FLASHBACK TABLE','GRANT OBJECT','INSERT','LOCK TABLE',/*'NO-OP',*/'NOAUDIT OBJECT',/*'PL/SQL EXECUTE',*/
		'PURGE DBA RECYCLEBIN','PURGE INDEX','PURGE TABLE','PURGE TABLESPACE','PURGE USER RECYCLEBIN','RENAME',
		'REVOKE OBJECT','ROLLBACK','SAVEPOINT','SELECT','SET CONSTRAINTS','SET ROLE','SET TRANSACTION',
		'TRUNCATE CLUSTER','TRUNCATE TABLE',/*'UNDROP OBJECT',*/'UPDATE',/*'UPDATE INDEXES',*/
		/*'UPDATE JOIN INDEX',*/'UPSERT'/*'VALIDATE INDEX',*/
	) then
		return build_statement_wo_semicolon(p_tokens);
	--Do nothing for these, they can end with a semicolon:
	elsif v_command_name in (
		'CREATE ASSEMBLY',
		'CREATE FUNCTION',
		'CREATE JAVA',
		'CREATE LIBRARY',
		'CREATE PACKAGE',
		'CREATE PACKAGE BODY',
		'CREATE PROCEDURE',
		'CREATE TRIGGER',
		'CREATE TYPE',
		'CREATE TYPE BODY',
		'PL/SQL EXECUTE',
		'Invalid',
		'Nothing'
	) then
		return build_statement_as_is(p_tokens);
	else
		raise_application_error(-20000, 'Cannot determine if statement needs a semicolon.'||
			'  The command name "'||v_command_name||'" is not recognized.');
	end if;
end remove_semicolon;


--------------------------------------------------------------------------------
function remove_sqlplus_delimiter(
	p_statement in nclob,
	p_sqlplus_delimiter in nvarchar2 default '/'
) return nclob
is
	v_tokens token_table := tokenizer.tokenize(p_statement);

	v_delimiter_begin_index number;
	v_delimiter_end_index number;

	v_2_token_before_delimiter token;
	v_1_token_before_delimiter token;
	v_potential_delimiter nclob;
	v_1_token_after_delimiter token;
	v_2_token_after_delimiter token;

	v_statement_without_delimiter nclob;
begin
	--Special cases.
	--
	--Throw an error if the delimiter is null.
	if p_sqlplus_delimiter is null then
		raise_application_error(-20000, 'The SQL*Plus delimiter cannot be NULL.');
	end if;
	--Throw an error if the delimiter contains whitespace.
	for i in 1 .. lengthc(p_sqlplus_delimiter) loop
		if tokenizer.is_lexical_whitespace(substrc(p_sqlplus_delimiter, i, 1)) then
			raise_application_error(-20001, 'The SQL*Plus delimiter cannot contain whitespace.');
		end if;
	end loop;
	--Return an empty string if the string is NULL.
	if p_statement is null then
		return null;
	end if;

	--Gather tokens before and after, and delimiter.
	--
	--Loop through all tokens in reverse order.
	for token_index in reverse 1 .. v_tokens.count loop
		--Look for the last non-whitespace/comment/EOF
		if v_tokens(token_index).type not in (tokenizer.c_whitespace, tokenizer.c_comment, tokenizer.c_eof) then
			v_delimiter_end_index := token_index;

			--Get tokens after delimiter.
			v_1_token_after_delimiter := v_tokens(token_index + 1);
			if token_index + 2 <= v_tokens.count then
				v_2_token_after_delimiter := v_tokens(token_index + 2);
			end if;

			--Get potential delimiter - go until whitespace or comment found.
			for delimiter_index in reverse 1 .. token_index loop
				--Build delimiter.
				if v_tokens(delimiter_index).type not in (tokenizer.c_whitespace, tokenizer.c_comment) then
					v_delimiter_begin_index := delimiter_index;
					v_potential_delimiter := v_tokens(delimiter_index).value || v_potential_delimiter;
				--If something else found, get tokens before delimiter and quit.
				else
					v_delimiter_begin_index := delimiter_index + 1;
					v_1_token_before_delimiter := v_tokens(delimiter_index);
					if delimiter_index - 1 >= 1 then
						v_2_token_before_delimiter := v_tokens(delimiter_index - 1);
					end if;
					exit;
				end if;
			end loop;

			--Quit outer loop.
			exit;
		end if;
	end loop;

	--DEBUG, TODO:
--	dbms_output.put_line('Before 2: '||case when v_2_token_before_delimiter is not null then v_2_token_before_delimiter.value end);
--	dbms_output.put_line('Before 1: '||case when v_1_token_before_delimiter is not null then v_1_token_before_delimiter.value end);
--	dbms_output.put_line('Potential Delimiter: '||v_potential_delimiter);
--	dbms_output.put_line('SQL*Plus Delimiter: '||p_sqlplus_delimiter);
--	dbms_output.put_line('After 1: '||case when v_1_token_after_delimiter is not null then v_1_token_after_delimiter.value end);
--	dbms_output.put_line('After 2: '||case when v_2_token_after_delimiter is not null then v_2_token_after_delimiter.value end);

	--Return the original statement if these conditions do not match:
	if
		--Delimiters must match.
		(p_sqlplus_delimiter = v_potential_delimiter) and
		--Before the delimiter, if anything, must be whitespace.
		(v_1_token_before_delimiter is null or v_1_token_before_delimiter.type = tokenizer.c_whitespace) and
		--If there are two tokens before then the first token before must have a newline.
		(v_2_token_before_delimiter is null or instr(v_1_token_before_delimiter.value, chr(10)) >= 1) and
		--After the delimiter, if anything, must be whitespace or EOF.
		(v_1_token_after_delimiter is null or v_1_token_after_delimiter.type in (tokenizer.c_whitespace, tokenizer.c_eof)) and
		--There is only one token after, or the second token after is EOF, or the first token after has a newline.
		(v_2_token_after_delimiter is null or v_2_token_after_delimiter.type = tokenizer.c_eof
		or
			(
				instr(v_1_token_after_delimiter.value, chr(10)) >= 1
			)
		)
	then
		null;
	else
		return p_statement;
	end if;

	--Put the string back together without the delimiter.
	if v_delimiter_begin_index is null then
		v_statement_without_delimiter := p_statement;
	else
		for i in 1 .. v_tokens.count loop
			if i not between v_delimiter_begin_index and v_delimiter_end_index then
				v_statement_without_delimiter := v_statement_without_delimiter || v_tokens(i).value;
			end if;
		end loop;
	end if;

	return v_statement_without_delimiter;
end remove_sqlplus_delimiter;


--------------------------------------------------------------------------------
function remove_semi_and_sqlplus_del(
	p_tokens in token_table,
	p_sqlplus_delimiter in nvarchar2 default '/'
) return nclob
is
begin
	--TODO
	return null;
end remove_semi_and_sqlplus_del;

end;
/
